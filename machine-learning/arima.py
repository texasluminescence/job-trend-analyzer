# -*- coding: utf-8 -*-
"""arima.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Kaeby7eVs8kW8aoYHJDMzRCmTSOD1UQR
"""

from google.colab import files


dataset = files.upload()

import pandas as pd
import numpy as np
import io

df = pd.read_csv(io.BytesIO(dataset['DataScience_salaries_2024 (1).csv']))
# save only required columns (work year and USD salary)
df.drop(["experience_level", "employment_type", "job_title", "salary", "salary_currency", "employee_residence", "remote_ratio", "company_location", "company_size"], axis=1, inplace=True)
df.dropna()
print(df)

num_jobs = df['work_year'].value_counts()
print(num_jobs)
# unevenly distributed jobs in terms of time -> implement weighted salary aggregation
# underrepresented years (2020-2022) will be weighted heavier; calculate frequency weights for each year
total_jobs = num_jobs.sum()
weights = total_jobs / (5 * num_jobs)
df["weight"] = df["work_year"].map(weights)
print(df)

# add timestamps to each job with uniform quarterly distribution to better fit an ARIMA model
np.random.seed(12) # random nums are now reproducible
df["month"] = np.random.choice(["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], size=len(df))
# YYYY-Q timestamp format
df["job_date"] = df["work_year"].astype(str) + "-" + df["month"]
# use datetime type
numbered_per_month = {"January": "-01", "February": "-02", "March": "-03", "April": "-04", "May": "-05", "June": "-06", "July": "-07", "August":"-08", "September":"-09", "October": "-10", "November": "-11", "December":"-12"}
df["job_date"] = pd.to_datetime(df["work_year"].astype(str) + df["month"].map(numbered_per_month) + "-01")
# sort over time
df = df.sort_values(by="job_date")
df.drop(["work_year", "month"], axis = 1, inplace = True)
print(df)

# Group by date and compute weighted salary mean
df_grouped = df.groupby("job_date").apply(lambda x: np.average(x["salary_in_usd"], weights=x["weight"])).reset_index()
df_grouped.columns = ["date", "weighted_salary"]

# Display final dataset
print(df_grouped)

import matplotlib.pyplot as plt
plt.figure(figsize=(10, 5))
plt.plot(df_grouped['date'], df_grouped['weighted_salary'], marker='o', linestyle='-')

# Labels and title
plt.xlabel('Date')
plt.ylabel('Salary')
plt.title('Time Series Line Plot')
plt.xticks(rotation=45)
plt.grid()

from statsmodels.graphics.tsaplots import plot_pacf
from statsmodels.graphics.tsaplots import plot_acf
import matplotlib.pyplot as plt

# show smoothed plot to get P and D values
plot_pacf(df_grouped["weighted_salary"].dropna(), lags=10)
plt.show()

plot_acf(df_grouped["weighted_salary"].dropna())
plt.show()

from statsmodels.tsa.arima.model import ARIMA

fig, (ax1, ax2, ax3) = plt.subplots(3)
plot_acf(df_grouped["weighted_salary"], ax=ax1)
plot_acf(df_grouped["weighted_salary"].diff().dropna(), ax=ax2)
plot_acf(df_grouped["weighted_salary"].diff().diff().dropna(), ax=ax3)

# confirm stationary nature of data- ADF test
from statsmodels.tsa.stattools import adfuller
result = adfuller(df_grouped["weighted_salary"])
print(f"ADF Statistic: {result[0]}, p-value: {result[1]}")  # if p > 0.05, apply differencing


# Apply first-order differencing
df_grouped['weighted_salary_diff'] = df_grouped['weighted_salary'].diff()


# Perform the Augmented Dickey-Fuller test on the differenced series
result_diff = adfuller(df_grouped["weighted_salary_diff"].dropna())
print(f"ADF Statistic (Differenced): {result_diff[0]:.4f}")
print(f"p-value (Differenced): {result_diff[1]:.4f}")


# plot the differenced graph of time vs. salary
plt.figure(figsize=(10, 5))
plt.plot(df_grouped.index, df_grouped['weighted_salary_diff'], marker='o', linestyle='-')

# Labels and title
plt.xlabel('Date')
plt.ylabel('Salary')
plt.title('Time Series Line Plot Differenced')
plt.xticks(rotation=45)
plt.grid()


# basic ARIMA model (for now, p, d, and q are placeholders for later tweaking)
model = ARIMA(df_grouped["weighted_salary"], order=(4,1,6))
model_fit = model.fit()
print(model_fit.summary())

# Forecast next 2 years (24 months)
forecast = model_fit.forecast(steps=24)

# Plot results
plt.figure(figsize=(12, 6))
plt.plot(df_grouped["date"], df_grouped["weighted_salary"], label="Observed", marker="o")
plt.plot(pd.date_range(start=df_grouped["date"].iloc[-1], periods=25, freq="M")[1:], forecast, label="Forecast", linestyle="dashed", marker="o")
plt.xlabel("Date")
plt.ylabel("Weighted Salary")
plt.title('Time Series Line Plot Forecasted')
plt.legend()
plt.show()
